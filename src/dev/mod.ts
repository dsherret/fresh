import {
  dirname,
  extname,
  fromFileUrl,
  join,
  toFileUrl,
  walk,
} from "./deps.ts";
import { error } from "./error.ts";

interface Manifest {
  routes: string[];
  islands: string[];
}

export async function collect(directory: string): Promise<Manifest> {
  const routesDir = join(directory, "./routes");
  const islandsDir = join(directory, "./islands");

  const routes = [];
  try {
    const routesUrl = toFileUrl(routesDir);
    // TODO(lucacasonato): remove the extranious Deno.readDir when
    // https://github.com/denoland/deno_std/issues/1310 is fixed.
    for await (const _ of Deno.readDir(routesDir)) {
      // do nothing
    }
    const routesFolder = walk(routesDir, {
      includeDirs: false,
      includeFiles: true,
      exts: ["tsx", "jsx", "ts", "js"],
    });
    for await (const entry of routesFolder) {
      if (entry.isFile) {
        const file = toFileUrl(entry.path).href.substring(
          routesUrl.href.length,
        );
        routes.push(file);
      }
    }
  } catch (err) {
    if (err instanceof Deno.errors.NotFound) {
      // Do nothing.
    } else {
      throw err;
    }
  }
  routes.sort();

  const islands = [];
  try {
    const islandsUrl = toFileUrl(islandsDir);
    for await (const entry of Deno.readDir(islandsDir)) {
      if (entry.isDirectory) {
        error(
          `Found subdirectory '${entry.name}' in islands/. The islands/ folder must not contain any subdirectories.`,
        );
      }
      if (entry.isFile) {
        const ext = extname(entry.name);
        if (![".tsx", ".jsx", ".ts", ".js"].includes(ext)) continue;
        const path = join(islandsDir, entry.name);
        const file = toFileUrl(path).href.substring(islandsUrl.href.length);
        islands.push(file);
      }
    }
  } catch (err) {
    if (err instanceof Deno.errors.NotFound) {
      // Do nothing.
    } else {
      throw err;
    }
  }
  islands.sort();

  return { routes, islands };
}

export async function generate(directory: string, manifest: Manifest) {
  const { routes, islands } = manifest;

  const output = `// DO NOT EDIT. This file is generated by fresh.
// This file SHOULD be checked into source version control.
// This file is automatically updated during development when running \`dev.ts\`.

${
    routes.map((file, i) => `import * as $${i} from "./routes${file}";`).join(
      "\n",
    )
  }
${
    islands.map((file, i) => `import * as $$${i} from "./islands${file}";`)
      .join("\n")
  }

const manifest = {
  routes: {
    ${
    routes.map((file, i) => `${JSON.stringify(`./routes${file}`)}: $${i},`)
      .join("\n    ")
  }
  },
  islands: {
    ${
    islands.map((file, i) => `${JSON.stringify(`./islands${file}`)}: $$${i},`)
      .join("\n    ")
  }
  },
  baseUrl: import.meta.url,
};

export default manifest;
`;

  const proc = Deno.run({
    cmd: [Deno.execPath(), "fmt", "-"],
    stdin: "piped",
    stdout: "piped",
    stderr: "null",
  });
  const raw = new ReadableStream({
    start(controller) {
      controller.enqueue(new TextEncoder().encode(output));
      controller.close();
    },
  });
  await raw.pipeTo(proc.stdin.writable);
  const out = await proc.output();
  await proc.status();
  proc.close();

  const manifestStr = new TextDecoder().decode(out);
  const manifestPath = join(directory, "./fresh.gen.ts");

  await Deno.writeTextFile(manifestPath, manifestStr);
  console.log(
    `%cThe manifest has been generated for ${routes.length} routes and ${islands.length} islands.`,
    "color: blue; font-weight: bold",
  );
}

export async function dev(base: string, entrypoint: string) {
  entrypoint = new URL(entrypoint, base).href;

  const dir = dirname(fromFileUrl(base));

  let currentManifest: Manifest;
  const prevManifest = Deno.env.get("FRSH_DEV_PREVIOUS_MANIFEST");
  if (prevManifest) {
    currentManifest = JSON.parse(prevManifest);
  } else {
    currentManifest = { islands: [], routes: [] };
  }
  const newManifest = await collect(dir);
  Deno.env.set("FRSH_DEV_PREVIOUS_MANIFEST", JSON.stringify(newManifest));

  const manifestChanged =
    !arraysEqual(newManifest.routes, currentManifest.routes) ||
    !arraysEqual(newManifest.islands, currentManifest.islands);

  if (manifestChanged) await generate(dir, newManifest);

  if (await updateNpmSpecifiers(newManifest, dir)) {
    // reset
    await dev(base, entrypoint);
  } else {
    await import(entrypoint);
  }
}

async function updateNpmSpecifiers(_manifest: Manifest, dir: string) {
  const importMapPath = join(dir, "import_map.json");
  const importMapText = await Deno.readTextFile(importMapPath);
  const importMap = JSON.parse(importMapText);
  const originalImportMapSnapshot = JSON.stringify(importMap);
  // todo: don't mutate the provided object in getDenoInfo
  const denoInfo = await getDenoInfo(dir, importMap);

  if (!denoInfo.npmPackages) {
    return false;
  }

  const foundReferences = new Set<string>();
  const npmPackageReferences = [];

  // todo: only analyze the tree of islands
  for (const module of denoInfo.modules) {
    if (module.dependencies) {
      for (const dep of module.dependencies) {
        if (dep.npmPackage != null && !foundReferences.has(dep.specifier)) {
          npmPackageReferences.push({
            specifier: dep.specifier,
            package: dep.npmPackage,
          });
          foundReferences.add(dep.specifier);
        }
      }
    }
  }

  for (const reference of npmPackageReferences) {
    const pkg = denoInfo.npmPackages![reference.package];
    let esmUrl = `https://esm.sh/${pkg.name}@${pkg.version}`;
    const deps = pkg.dependencies.map((depId) => {
      const dep = denoInfo.npmPackages![depId];
      return `${dep.name}@${dep.version}`;
    });
    if (deps.length > 0) {
      // very buggy
      // esmUrl += "?deps=" + deps.join(",");
    }
    importMap.imports[reference.specifier] = esmUrl;
  }
  if (originalImportMapSnapshot === JSON.stringify(importMap)) {
    return false;
  }

  // todo: use deno fmt
  await Deno.writeTextFile(
    importMapPath,
    JSON.stringify(importMap, undefined, 2) + "\n",
  );
  return true;
}

interface DenoInfo {
  modules: DenoInfoModule[];
  npmPackages?: Record<string, DenoInfoNpmPackage>;
}

interface DenoInfoModule {
  specifier: string;
  dependencies?: DenoInfoModuleDependency[];
}

interface DenoInfoModuleDependency {
  specifier: string;
  code: DenoInfoModuleDependencyCode;
  npmPackage?: string;
}

interface DenoInfoModuleDependencyCode {
  specifier: string;
}

interface DenoInfoNpmPackage {
  name: string;
  version: string;
  dependencies: string[];
}

async function getDenoInfo(dir: string, importMap: any) {
  for (const key of Object.keys(importMap.imports)) {
    if (isNpmPackageReference(key)) {
      delete importMap.imports[key];
    }
  }

  const importMapUri = `data:application/json;base64,${
    btoa(JSON.stringify(importMap))
  }`;
  const proc = Deno.run({
    cmd: [
      "V:\\deno\\target\\debug\\deno.exe",
      "info",
      "--import-map",
      importMapUri,
      "--json",
      "main.ts",
    ],
    cwd: dir,
    stdout: "piped",
    stderr: "piped",
  });
  const [out, stderrOutput] = await Promise.all([
    proc.output(),
    proc.stderrOutput(),
  ]);
  const status = await proc.status();
  if (!status.success) {
    console.error(new TextDecoder().decode(stderrOutput));
    throw new Error("Failed getting deno info.");
  }
  proc.close();
  const outputText = new TextDecoder().decode(out);
  const outputData = JSON.parse(outputText);
  return outputData as DenoInfo;
}

function isNpmPackageReference(rawText: string) {
  return rawText.startsWith("npm:");
}

function arraysEqual<T>(a: T[], b: T[]): boolean {
  if (a.length !== b.length) return false;
  for (let i = 0; i < a.length; ++i) {
    if (a[i] !== b[i]) return false;
  }
  return true;
}
